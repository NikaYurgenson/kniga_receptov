import requests
from bs4 import BeautifulSoup
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.contrib.fsm_storage.memory import MemoryStorage
import random

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ===
API_TOKEN = '7698307619:AAGx2vEsBAJ2zzk-O-fFljcfhtT9c80Cz9I'  # –£–∫–∞–∂–∏ —Å–≤–æ–π —Ç–æ–∫–µ–Ω

# === FSM ===
class Form(StatesGroup):
    category = State()

# === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===
bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot, storage=MemoryStorage())

# === –ö–Ω–æ–ø–∫–∏ ===
category_kb = InlineKeyboardMarkup(row_width=3)
category_kb.add(
    InlineKeyboardButton(text='–°—É–ø—ã', callback_data='category_soups'),
    InlineKeyboardButton(text='–°–∞–ª–∞—Ç—ã', callback_data='category_salads'),
    InlineKeyboardButton(text='–ö–∞—à–∏', callback_data='category_porridge'),
    InlineKeyboardButton(text='–ì–∞—Ä–Ω–∏—Ä—ã', callback_data='category_sides'),
    InlineKeyboardButton(text='–†—ã–±–∞', callback_data='category_fish'),
    InlineKeyboardButton(text='–ú—è—Å–æ', callback_data='category_meat'),
    InlineKeyboardButton(text='–î–µ—Å–µ—Ä—Ç—ã', callback_data='category_dessert')
)

# === URL –∫–∞—Ç–µ–≥–æ—Ä–∏–π povarenok.ru ===
CATEGORY_URLS = {
    'soups': 'https://www.povarenok.ru/recipes/category/3/',
    'salads': 'https://www.povarenok.ru/recipes/category/1/',
    'porridge': 'https://www.povarenok.ru/recipes/category/24/',
    'sides': 'https://www.povarenok.ru/recipes/category/22/',
    'fish': 'https://www.povarenok.ru/recipes/category/17/',
    'meat': 'https://www.povarenok.ru/recipes/category/14/',
    'dessert': 'https://www.povarenok.ru/recipes/category/30/'
}

HEADERS = {
    "User-Agent": "Mozilla/5.0"
}

# === –ü–∞—Ä—Å–µ—Ä –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ —Ä–µ—Ü–µ–ø—Ç–∞ —Å –∫—Ä–∞—Å–∏–≤—ã–º –≤—ã–≤–æ–¥–æ–º ===
def parse_full_recipe(recipe_url):
    response = requests.get(recipe_url, headers=HEADERS)
    response.raise_for_status()
    soup = BeautifulSoup(response.text, 'html.parser')

    # –ù–∞–∑–≤–∞–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–∞
    title_tag = soup.find('h1')
    title = title_tag.get_text(strip=True) if title_tag else "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"

    # –ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã
    ingredients = []
    ingr_section = soup.find('div', class_='ingredients')
    if not ingr_section:
        ingr_section = soup.find('div', class_='ingredients-bl')
    if ingr_section:
        for li in ingr_section.find_all('li'):
            ingr_text = li.get_text(separator=' ', strip=True)
            if ingr_text:
                ingredients.append(ingr_text)

    # –ü–æ—à–∞–≥–æ–≤—ã–π —Ä–µ—Ü–µ–ø—Ç
    steps = []
    ul = soup.find('ul', itemprop='recipeInstructions')
    if ul:
        for li in ul.find_all('li', class_='cooking-bl'):
            p = li.find('p')
            if p:
                step_text = p.get_text(separator=' ', strip=True)
                steps.append(step_text)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞ —Å —ç–º–æ–¥–∑–∏ –∏ –∫—Ä–∞—Å–∏–≤—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    text = f"üçΩ <b>{title}</b>\n\n"

    text += "üõí <b>–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã:</b>\n"
    if ingredients:
        for ingr in ingredients:
            text += f"  ‚Ä¢ {ingr}\n"
    else:
        text += "  –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.\n"

    text += "\nüë©‚Äçüç≥ <b>–ü—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ:</b>\n"
    if steps:
        for i, step in enumerate(steps, 1):
            text += f"  {i}. {step}\n\n"
    else:
        text += "  –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.\n"

    text += f"\nüîó <i>–ò—Å—Ç–æ—á–Ω–∏–∫: <a href='{recipe_url}'>Povarenok.ru</a></i>"

    return text

# === –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ—Ü–µ–ø—Ç–æ–≤ –∏–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ===
def get_recipes_from_category(category, limit=10):
    url = CATEGORY_URLS.get(category)
    if not url:
        return []

    response = requests.get(url, headers=HEADERS)
    soup = BeautifulSoup(response.text, 'html.parser')
    articles = soup.find_all('article', class_='item-bl')

    recipes = []
    for article in articles[:limit]:
        a_tag = article.find('a')
        if not a_tag:
            continue
        link = a_tag['href']
        if not link.startswith('http'):
            link = "https://www.povarenok.ru" + link
        recipes.append(link)

    return recipes

# === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ===
@dp.message_handler(commands=['start'])
async def cmd_start(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç! –Ø –≤–∞—à –∫—É–ª–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫. –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Ä–µ—Ü–µ–ø—Ç–æ–≤.", reply_markup=category_kb)
    await Form.category.set()

@dp.callback_query_handler(lambda c: c.data and c.data.startswith('category_'), state=Form.category)
async def process_category(callback_query: types.CallbackQuery, state: FSMContext):
    category = callback_query.data.split('_')[1]
    await state.update_data(category=category)
    await callback_query.answer()

    recipes = get_recipes_from_category(category)

    if not recipes:
        await callback_query.message.answer("–†–µ—Ü–µ–ø—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        await state.finish()
        return

    recipe_url = random.choice(recipes)
    try:
        full_text = parse_full_recipe(recipe_url)
        await callback_query.message.answer(full_text, parse_mode='HTML', disable_web_page_preview=True)
    except Exception as e:
        await callback_query.message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–µ—Ü–µ–ø—Ç–∞.")
        print(f"Error: {e}")

    await state.finish()

# === –ó–∞–ø—É—Å–∫ ===
if __name__ == '__main__':
    from aiogram import executor
    executor.start_polling(dp, skip_updates=True)
